use std::fmt;

#[derive(Debug, PartialEq)]
pub enum SelfError {
    AccountAlreadyConfigured,
    AccountNotConfigured,
    CredentialAlreadySigned,
    CredentialContextMissing,
    CredentialEncodingInvalid,
    CredentialIssuedMissing,
    CredentialIssuerMissing,
    CredentialSignatureInvalid,
    CredentialSignerMismatch,
    CredentialSignerMissing,
    CredentialSubjectMissing,
    CredentialTypeMissing,
    CredentialValidFromMissing,
    CryptoAEADDecryptFailed,
    CryptoBoxOpenFailed,
    DIDAddressInvalid,
    DIDAddressMethodInvalid,
    DIDAddressSchemeInvalid,
    HashgraphDeactivated,
    HashgraphDuplicateAction,
    HashgraphDuplicateKey,
    HashgraphDuplicateSigner,
    HashgraphInvalidAction,
    HashgraphInvalidControllerLength,
    HashgraphInvalidDescription,
    HashgraphInvalidEmbeddedDescription,
    HashgraphInvalidKeyLength,
    HashgraphInvalidKeyReuse,
    HashgraphInvalidModify,
    HashgraphInvalidPreviousHash,
    HashgraphInvalidRecover,
    HashgraphInvalidRevocationTimestamp,
    HashgraphInvalidRevoke,
    HashgraphInvalidSignature,
    HashgraphInvalidSignatureHeader,
    HashgraphInvalidSignatureLength,
    HashgraphInvalidSignerLength,
    HashgraphInvalidState,
    HashgraphInvalidTimestamp,
    HashgraphKeyAlreadyRevoked,
    HashgraphModifyNOOP,
    HashgraphMultiRoleKeyViolation,
    HashgraphNoActiveKeys,
    HashgraphNoRolesAssigned,
    HashgraphNotEnoughSigners,
    HashgraphOperationInvalid,
    HashgraphOperationMissing,
    HashgraphOperationNOOP,
    HashgraphOperationSequenceOutOfOrder,
    HashgraphOperationUnauthorized,
    HashgraphOperationUnsigned,
    HashgraphOperationVersionInvalid,
    HashgraphReferencedDescriptionNotFound,
    HashgraphSelfSignatureRequired,
    HashgraphSignerRoleInvalid,
    HashgraphSignerUnknown,
    HashgraphSigningKeyRevoked,
    HTTPRequestConnectionFailed,
    HTTPRequestConnectionTimeout,
    HTTPRequestInvalid,
    HTTPRequestRedirected,
    HTTPRequestUnknown,
    HTTPRequestURLInvalid,
    HTTPResponseBadRequest,
    HTTPResponseConflict,
    HTTPResponseForbidden,
    HTTPResponseInternalServerError,
    HTTPResponseNotAcceptable,
    HTTPResponseNotFound,
    HTTPResponsePayloadTooLarge,
    HTTPResponseServiceUnavailable,
    HTTPResponseUnauthorized,
    HTTPResponseUnexpected,
    HTTPResposeBodyInvalid,
    KeychainKeyExists,
    KeychainKeyNotFound,
    KeyPairAlgorithmUnknown,
    KeyPairConversionFailed,
    KeyPairDataIncorrectLength,
    KeyPairDecodeInvalidData,
    KeyPairNotFound,
    KeyPairPublicKeyInvalidLength,
    KeyPairSignFailure,
    KeyPairSignMissingSingingKey,
    KeyPairSignWrongKeypairType,
    MessageContentMissing,
    MessageContentUnknown,
    MessageEncodingInvalid,
    MessagePayloadInvalid,
    MessagePresentationDetailInvalid,
    MessageRecipientMissing,
    MessageResponseStatusMissing,
    MessageSenderMissing,
    ObjectDataInvalid,
    ObjectKeyMissing,
    PresentationContextMissing,
    PresentationEncodingInvalid,
    PresentationHolderMissing,
    PresentationSignatureInvalid,
    PresentationSignerMismatch,
    PresentationSignerMissing,
    PresentationTypeMissing,
    RpcBadGateway,
    RpcBadRequest,
    RpcConflict,
    RpcConnectionFailed,
    RpcConnectionTimeout,
    RpcExpectationFailed,
    RpcForbidden,
    RpcGatewayTimeout,
    RpcGone,
    RpcInternalServerError,
    RpcLengthRequired,
    RpcMethodNotAllowed,
    RpcNotAcceptable,
    RpcNotFound,
    RpcNotImplemented,
    RpcPaymentRequired,
    RpcPreconditionFailed,
    RpcRequestEntityTooLarge,
    RpcRequestFailed,
    RpcRequestTimeout,
    RpcServiceUnavailable,
    RpcUnauthorized,
    RpcUnknown,
    StorageAbort,
    StorageAuth,
    StorageBusy,
    StorageCantOpen,
    StorageColumnTypeMismatch,
    StorageConnectionFailed,
    StorageConstraint,
    StorageCorrupt,
    StorageFull,
    StorageInternal,
    StorageInterrupt,
    StorageIOError,
    StorageLocked,
    StorageMismatch,
    StorageMisuse,
    StorageNoLFS,
    StorageNoMem,
    StorageNotADB,
    StorageNotFound,
    StoragePermissions,
    StorageProtocol,
    StorageRange,
    StorageReadOnly,
    StorageSchema,
    StorageSessionNotFound,
    StorageTableCreationFailed,
    StorageTextUtf8Invalid,
    StorageTooBig,
    StorageTransactionCommitFailed,
    StorageTransactionCreationFailed,
    StorageTransactionRollbackFailed,
    StorageUnknown,
    TimeDatetimeInvalid,
    TokenEncodingInvalid,
    TokenSignatureInvalid,
    TokenTypeInvalid,
    TokenVersionInvalid,
    WebsocketEventTimestampInvalid,
    WebsocketProtocolEmptyContent,
    WebsocketProtocolEncodingInvalid,
    WebsocketProtocolErrorUnknown,
    WebsocketProtocolRecipientInvalid,
    WebsocketProtocolSenderInvalid,
    WebsocketTokenUnsupported,
}

impl std::error::Error for SelfError {}

impl fmt::Display for SelfError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            SelfError::AccountAlreadyConfigured => write!(f, "Account has already been configured"),
            SelfError::AccountNotConfigured => write!(f, "Account has not been configured"),
            SelfError::CredentialAlreadySigned => write!(f, "Credential already signed"),
            SelfError::CredentialContextMissing => write!(f, "Credential context missing"),
            SelfError::CredentialEncodingInvalid => write!(f, "Credential encoding invalid"),
            SelfError::CredentialIssuedMissing => write!(f, "Credential issued timestamp missing"),
            SelfError::CredentialIssuerMissing => write!(f, "Credential issuer missing"),
            SelfError::CredentialSignatureInvalid => write!(f, "Credential signature invalid"),
            SelfError::CredentialSignerMismatch => write!(f, "Credential signer does not match issuer"),
            SelfError::CredentialSignerMissing => write!(f, "Credential signer missing"),
            SelfError::CredentialSubjectMissing => write!(f, "Credential subject missing"),
            SelfError::CredentialTypeMissing => write!(f, "Credential type missing"),
            SelfError::CredentialValidFromMissing => write!(f, "Credential valid from timestamp missing"),
            SelfError::CryptoAEADDecryptFailed => write!(f, "AEAD encrypted data could not be decrypted"),
            SelfError::CryptoBoxOpenFailed => write!(f, "Crypto box could not be decrypted"),
            SelfError::DIDAddressInvalid => write!(f, "did address invalid"),
            SelfError::DIDAddressMethodInvalid => write!(f, "did address method invalid"),
            SelfError::DIDAddressSchemeInvalid => write!(f, "did address scheme invalid"),
            SelfError::HashgraphDeactivated => write!(f, "Hashgraph has been deactivated and cannot be updated"),
            SelfError::HashgraphDuplicateAction => write!(f, "Hashgraph operation performs more than one action on a key"),
            SelfError::HashgraphDuplicateKey => write!(f, "Hashgraph operation adds a key that already exists"),
            SelfError::HashgraphDuplicateSigner => write!(f, "Hashgraph operation has been signed by the same key more than once"),
            SelfError::HashgraphInvalidAction => write!(f, "Hashgraph action invalid"),
            SelfError::HashgraphInvalidDescription => write!(f, "Hashgraph description invalid"),
            SelfError::HashgraphInvalidControllerLength => write!(f, "Hashgraph controller length invalid"),
            SelfError::HashgraphInvalidEmbeddedDescription => write!(f, "Hashgraph embedded key usage invalid"),
            SelfError::HashgraphInvalidKeyLength => write!(f, "Hashgraph key identifier length invalid"),
            SelfError::HashgraphInvalidKeyReuse => write!(f, "Hashgraph key cannot be assigned additional roles"),
            SelfError::HashgraphInvalidModify => write!(f, "Hashgraph modify action not permitted in initial operation"),
            SelfError::HashgraphInvalidPreviousHash => write!(f, "Hashgraph operation specifies a previous hash that does not match"),
            SelfError::HashgraphInvalidRecover => write!(f, "Hashgraph recover action not permitted in initial operation"),
            SelfError::HashgraphInvalidRevocationTimestamp => write!(f, "Hashgraph revocation timestamp before the target keys creation"),
            SelfError::HashgraphInvalidRevoke => write!(f, "Hashgraph revoke action not permitted in initial operation"),
            SelfError::HashgraphInvalidSignature => write!(f, "Hashgraph operation signature could not be verified"),
            SelfError::HashgraphInvalidSignatureHeader => write!(f, "Hashgraph signature header must be specified"),
            SelfError::HashgraphInvalidSignatureLength => write!(f, "Hashgraph signature length invalid"),
            SelfError::HashgraphInvalidSignerLength => write!(f, "Hashgraph signer length invalid"),
            SelfError::HashgraphInvalidState => write!(f, "Hashgraph is in an invalid state"),
            SelfError::HashgraphInvalidTimestamp => write!(f, "Hashgraph operation timestamp is before the previous operations"),
            SelfError::HashgraphKeyAlreadyRevoked => write!(f, "Hashgraph action revokes an already revoked key"),
            SelfError::HashgraphModifyNOOP => write!(f, "Hashgraph action makes no modification"),
            SelfError::HashgraphMultiRoleKeyViolation => write!(f, "Hashgraph key is not permitted to be assigned to multiple roles"),
            SelfError::HashgraphNoActiveKeys => write!(f, "Hashgraph has no active keys"),
            SelfError::HashgraphNoRolesAssigned => write!(f, "Hashgraph key has no roles assigned"),
            SelfError::HashgraphNotEnoughSigners => write!(f, "Hashgraph operation has not been signed by a sufficient amount of keys"),
            SelfError::HashgraphOperationInvalid => write!(f, "Hashgraph operation invalid"),
            SelfError::HashgraphOperationMissing => write!(f, "Hashgraph operation state has not been specified"),
            SelfError::HashgraphOperationNOOP => write!(f, "Hashgraph operation has no actions"),
            SelfError::HashgraphOperationSequenceOutOfOrder => write!(f, "Hashgraph operation sequence out of order"),
            SelfError::HashgraphOperationUnauthorized => write!(f, "Hashgraph operation must be signed by a key with the correct invocation role"),
            SelfError::HashgraphOperationUnsigned => write!(f, "Hashgraph operation must be signed by an existing valid key"),
            SelfError::HashgraphOperationVersionInvalid => write!(f, "Hashgraph operation version invalid"),
            SelfError::HashgraphReferencedDescriptionNotFound => write!(f, "Hashgraph action references a key that cannot be found"),
            SelfError::HashgraphSelfSignatureRequired => write!(f, "Hashgraph action adds a key that has not signed the operation"),
            SelfError::HashgraphSignerRoleInvalid => write!(f, "Hashgraph operation has been signed by a key that does not have the invocation role"),
            SelfError::HashgraphSignerUnknown => write!(f, "Hashgraph operation has been signed by an unknown key"),
            SelfError::HashgraphSigningKeyRevoked => write!(f, "Hashgraph operation has been signed by a key that has been revoked"),
            SelfError::HTTPRequestConnectionFailed => write!(f, "HTTP request connection failed"),
            SelfError::HTTPRequestConnectionTimeout => write!(f, "HTTP request connection timeout"),
            SelfError::HTTPRequestInvalid => write!(f, "HTTP request invalid"),
            SelfError::HTTPRequestRedirected => write!(f, "HTTP request was redirected too many times"),
            SelfError::HTTPRequestUnknown => write!(f, "HTTP request failed with unknown error"),
            SelfError::HTTPRequestURLInvalid => write!(f, "HTTP request URL is invalid"),
            SelfError::HTTPResponseBadRequest => write!(f, "HTTP response bad request"),
            SelfError::HTTPResponseConflict => write!(f, "HTTP response conflict"),
            SelfError::HTTPResponseForbidden => write!(f, "HTTP response forbidden"),
            SelfError::HTTPResponseInternalServerError => write!(f, "HTTP response internal server error"),
            SelfError::HTTPResponseNotAcceptable => write!(f, "HTTP response not acceptable"),
            SelfError::HTTPResponseNotFound => write!(f, "HTTP response not found"),
            SelfError::HTTPResponsePayloadTooLarge => write!(f, "HTTP response payload too large"),
            SelfError::HTTPResponseServiceUnavailable => write!(f, "HTTP response unavailable"),
            SelfError::HTTPResponseUnauthorized => write!(f, "HTTP response unauthorized"),
            SelfError::HTTPResponseUnexpected => write!(f, "HTTP response status was unexpected"),
            SelfError::HTTPResposeBodyInvalid => write!(f, "HTTP response body encoding invalid"),
            SelfError::KeychainKeyExists => write!(f, "Keychain key already exists"),
            SelfError::KeychainKeyNotFound => write!(f, "Keychain key not found"),
            SelfError::KeyPairAlgorithmUnknown => write!(f, "Keypair algorithm unsupported"),
            SelfError::KeyPairConversionFailed => write!(f, "Keypair conversion failed"),
            SelfError::KeyPairDataIncorrectLength => write!(f, "Keypair public or secret key data length is incorrect"),
            SelfError::KeyPairDecodeInvalidData => write!(f, "Keypair could not be decoded"),
            SelfError::KeyPairNotFound => write!(f, "Keypair not found"),
            SelfError::KeyPairPublicKeyInvalidLength => write!(f, "Keypair public key is an incorrect length"),
            SelfError::KeyPairSignFailure => write!(f, "Keypair signing failed"),
            SelfError::KeyPairSignMissingSingingKey => write!(f, "Keypair cannot be used to sign as its missing it's secret key component"),
            SelfError::KeyPairSignWrongKeypairType => write!(f, "Keypair cannot be used to sign messages"),
            SelfError::MessageContentMissing => write!(f, "Message content is missing"),
            SelfError::MessageContentUnknown => write!(f, "Message content unknown"),
            SelfError::MessageEncodingInvalid => write!(f, "Message encoding invalid"),
            SelfError::MessagePayloadInvalid => write!(f, "Message payload is invalid"),
            SelfError::MessagePresentationDetailInvalid => write!(f, "Message request presentation detail invalid"),
            SelfError::MessageRecipientMissing => write!(f, "Message recipient missing"),
            SelfError::MessageResponseStatusMissing => write!(f, "Message response status missing"),
            SelfError::MessageSenderMissing => write!(f, "Message sender missing"),
            SelfError::ObjectDataInvalid => write!(f, "Object data invalid"),
            SelfError::ObjectKeyMissing => write!(f, "Object encryption key missing"),
            SelfError::PresentationContextMissing => write!(f, "Presentation context is missing"),
            SelfError::PresentationEncodingInvalid => write!(f, "Presentation encoding invalid"),
            SelfError::PresentationHolderMissing => write!(f, "Presentation holder is missing"),
            SelfError::PresentationSignatureInvalid => write!(f, "Presentation signature invalid"),
            SelfError::PresentationSignerMismatch => write!(f, "Presentation signing key does not match the credential subjects address"),
            SelfError::PresentationSignerMissing => write!(f, "Presentation signer missing"),
            SelfError::PresentationTypeMissing => write!(f, "Presentation type is missing"),
            SelfError::RpcConnectionFailed => write!(f, "Rpc connection failed"),
            SelfError::RpcConnectionTimeout => write!(f, "Rpc connection timeout"),
            SelfError::RpcBadGateway => write!(f, "Rpc bad gateway"),
            SelfError::RpcBadRequest => write!(f, "Rpc bad request"),
            SelfError::RpcConflict => write!(f, "Rpc conflict"),
            SelfError::RpcExpectationFailed => write!(f, "Rpc expectation failed"),
            SelfError::RpcForbidden => write!(f, "Rpc forbidden"),
            SelfError::RpcGatewayTimeout => write!(f, "Rpc gateway timeout"),
            SelfError::RpcGone => write!(f, "Rpc gone"),
            SelfError::RpcInternalServerError => write!(f, "Rpc internal server error"),
            SelfError::RpcLengthRequired => write!(f, "Rpc length required"),
            SelfError::RpcMethodNotAllowed => write!(f, "Rpc method not allowed"),
            SelfError::RpcNotAcceptable => write!(f, "Rpc not acceptable"),
            SelfError::RpcNotFound => write!(f, "Rpc not found"),
            SelfError::RpcNotImplemented => write!(f, "Rpc not implemented"),
            SelfError::RpcPaymentRequired => write!(f, "Rpc payment required"),
            SelfError::RpcPreconditionFailed => write!(f, "Rpc precondition failed"),
            SelfError::RpcRequestEntityTooLarge => write!(f, "Rpc request entity too large"),
            SelfError::RpcRequestFailed => write!(f, "Rpc request failed"),
            SelfError::RpcRequestTimeout => write!(f, "Rpc request timeout"),
            SelfError::RpcServiceUnavailable => write!(f, "Rpc service unavailable"),
            SelfError::RpcUnauthorized => write!(f, "Rpc unauthorized"),
            SelfError::RpcUnknown => write!(f, "Rpc unknown error"),
            SelfError::StorageColumnTypeMismatch => write!(f, "Storage column type mismatch"),
            SelfError::StorageAbort => write!(f, "Storage operation was aborted prior to completion"),
            SelfError::StorageAuth => write!(f, "Storage statement being prepared is not authorized"),
            SelfError::StorageBusy => write!(f, "Storage could not be written to or read from because of concurrent activity"),
            SelfError::StorageCantOpen => write!(f, "Storage could not be opened"),
            SelfError::StorageConnectionFailed => write!(f, "Storage connection failed"),
            SelfError::StorageConstraint => write!(f, "Storage constraint was failed while processing statement"),
            SelfError::StorageCorrupt => write!(f, "Storage has been corrupted"),
            SelfError::StorageFull => write!(f, "Storage write could not complete because the disk is full"),
            SelfError::StorageInternal => write!(f, "Storage internal malfunction"),
            SelfError::StorageInterrupt => write!(f, "Storage operation was interrupted"),
            SelfError::StorageIOError => write!(f, "Storage operation could not finish because the operating system reported an I/O error"),
            SelfError::StorageLocked => write!(f, "Storage write operation could not continue because of a conflict"),
            SelfError::StorageMismatch => write!(f, "Storage datatype mismatch"),
            SelfError::StorageMisuse => write!(f, "Storage misuse of internal api"),
            SelfError::StorageNoLFS => write!(f, "Storage unable to grow database due to lack of OS support for large files"),
            SelfError::StorageNoMem => write!(f, "Storage unable to allocate all the memory it needed to complete the operation"),
            SelfError::StorageNotADB => write!(f, "Storage file being opened does not appear to be an SQLite database file"),
            SelfError::StorageNotFound => write!(f, "Storage not found"),
            SelfError::StoragePermissions => write!(f, "Storage current database connection does not have write permission"),
            SelfError::StorageProtocol => write!(f, "Storage problem with file locking protocol"),
            SelfError::StorageRange => write!(f, "Storage parameter number argument is out of range"),
            SelfError::StorageReadOnly => write!(f, "Storage current database connection does not have write permission"),
            SelfError::StorageSchema => write!(f, "Storage database schema has changed"),
            SelfError::StorageSessionNotFound => write!(f, "Session not found"),
            SelfError::StorageTableCreationFailed => write!(f, "Storage table creation failed"),
            SelfError::StorageTextUtf8Invalid => write!(f, "Storage row text is invalid utf-8"),
            SelfError::StorageTooBig => write!(f, "Storage string or BLOB was too large"),
            SelfError::StorageTransactionCommitFailed => write!(f, "Storage transaction commit failed"),
            SelfError::StorageTransactionCreationFailed => write!(f, "Storage transaction creation failed"),
            SelfError::StorageTransactionRollbackFailed => write!(f, "Storage transaction rollback failed"),
            SelfError::StorageUnknown => write!(f, "Storage unknown error"),
            SelfError::TimeDatetimeInvalid => write!(f, "Date timestamp could not be parsed"),
            SelfError::TokenEncodingInvalid => write!(f, "Token could not be encoded"),
            SelfError::TokenSignatureInvalid => write!(f, "Token signature invalid"),
            SelfError::TokenTypeInvalid => write!(f, "Token type invalid or unsupported"),
            SelfError::TokenVersionInvalid => write!(f, "Token version not supported"),
            SelfError::WebsocketEventTimestampInvalid => write!(f, "Websocket event timestamp invalid"),
            SelfError::WebsocketProtocolEmptyContent => write!(f, "Websocket protocol event had no content"),
            SelfError::WebsocketProtocolEncodingInvalid => write!(f, "Websocket protocol event could not be decoded"),
            SelfError::WebsocketProtocolErrorUnknown => write!(f, "Websocket protocol error code is unknown"),
            SelfError::WebsocketProtocolRecipientInvalid => write!(f, "Websocket protocol message recipient invalid"),
            SelfError::WebsocketProtocolSenderInvalid => write!(f, "Websocket protocol message sender invalid"),
            SelfError::WebsocketTokenUnsupported => write!(f, "Websocket send attempted with an unsupported token"),
        }
    }
}
